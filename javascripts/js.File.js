// Generated by CoffeeScript 1.8.0

/*
Implements reading and writing of data to local files using HTML5.
Provides limited support of mime types.
Binary files are read and written in binary64 format.
Warning: Some MIME types that are assumed to be binary may be actually be textual.
Text files are read or written unchanged, i.e. there is no conversion
in between the standards where lines are separated by CR-character-only
(ASCII 13=0x0D=\r) or by CR and LF (ASCII 10=0x0D=\n).
Note: While CR-LF is Windows standard, CR-only is on most other platforms.
Note: Use content.replace(/\n/g,'\r\n') to convert to Windows standard.
Note: Reading is asynchronous, i.e. clients need to provide a callback that consumes data once it's read(y)
Useable only if browser supports HTML5 File APIs, provides for testing such support.
Assumes that jQuery is/will be loaded
(Could be a jQuery plugin)
(Could be a promise/deferred)
(Could be extended to support writing and reading files by dragging them from and to an area on a page)
Copyright 2014 Jan Stelovsky, MIT license (use as you wish, don't complain:)
 */

(function() {
  if (window.js == null) {
    window.js = {};
  }

  window.js.File = (function() {
    var binary64Extension;

    function File() {}

    File.extensions = {
      text: {
        txt: 'text/plain',
        html: 'text/html',
        htm: 'text/html',
        css: 'text/css',
        coffee: 'text/coffee',
        js: 'application/javascript',
        json: 'application/json',
        xml: 'application/xml',
        dtd: 'application/xml-dtd',
        sh: 'application/x-sh',
        axs: 'application/olescript',
        tcl: 'application/x-tcl',
        src: 'application/x-wais-source',
        c: 'text/plain',
        h: 'text/plain',
        csh: 'application/x-csh'
      },
      webImage: {
        png: 'image/png',
        jpeg: 'image/jpeg',
        jpg: 'image/jpeg'
      },
      MyImage: {
        imagefile: 'image/imagefile'
      },
      binary: {
        svg: 'image/svg+xml',
        bmp: 'image/bmp',
        ico: 'image/x-icon',
        rgb: 'image/x-rgb',
        tif: 'image/tiff',
        tiff: 'image/tiff',
        snd: 'audio/basic',
        wav: 'audio/x-wav',
        au: 'audio/basic',
        aif: 'audio/x-aiff',
        aifc: 'audio/x-aiff',
        aiff: 'audio/x-aiff',
        rmi: 'audio/mid',
        ra: 'audio/x-pn-realaudio',
        ram: 'audio/x-pn-realaudio',
        mp3: 'audio/mpeg',
        mpeg: 'video/mpeg',
        mpg: 'video/mpeg',
        mp2: 'video/mpeg',
        mpv2: 'video/mpeg',
        mpa: 'video/mpeg',
        mpe: 'video/mpeg',
        mov: 'video/quicktime',
        qt: 'video/quicktime',
        asf: 'video/x-ms-asf',
        asr: 'video/x-ms-asf',
        asx: 'video/x-ms-asf',
        avi: 'video/x-msvideo',
        movie: 'video/x-sgi-movie',
        bin: 'application/octet-stream',
        "class": 'application/octet-stream',
        exe: 'application/octet-stream',
        dll: 'application/x-msdownload',
        crt: 'application/x-x509-ca-cert',
        cer: 'application/x-x509-ca-cert',
        hqx: 'application/mac-binhex40',
        doc: 'application/msword',
        docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        rtf: 'application/rtf',
        xls: 'application/vnd.ms-excel',
        xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        pps: 'application/vnd.ms-powerpoint',
        ppsx: 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',
        ppt: 'application/vnd.ms-powerpoint',
        pptx: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
        mdb: 'application/x-msaccess',
        swf: 'application/x-shockwave-flash',
        tar: 'application/x-tar',
        tex: 'application/x-tex',
        latex: 'application/x-latex',
        pdf: 'application/pdf',
        ai: 'application/postscript',
        eps: 'application/postscript',
        ps: 'application/postscript',
        sit: 'application/x-stuffit',
        z: 'application/x-compress',
        tgz: 'application/x-compressed',
        z: 'application/x-compress',
        zip: 'application/zip',
        gtar: 'application/x-gtar',
        gz: 'application/x-gzip'
      }
    };

    File.types = {};

    File.defaultType = 'text/plain';

    File.dom = {};

    binary64Extension = 'b64';

    $(function() {
      var allExtensions, api, extension, key, type, types, values, _i, _len, _ref, _ref1;
      File.types = {};
      allExtensions = {};
      _ref = File.extensions;
      for (key in _ref) {
        values = _ref[key];
        types = {};
        for (extension in values) {
          type = values[extension];
          types[type] = type;
        }
        allExtensions = js.Support.merge(allExtensions, values);
        File.types[key] = types;
      }
      File.extensions.all = allExtensions;
      File.dom.body = $('body');
      File.supported = [];
      File.unsupported = [];
      _ref1 = ['File', 'FileReader', 'FileList', 'Blob', 'URL'];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        api = _ref1[_i];
        if (window[api] != null) {
          File.supported.push(api);
        } else {
          File.unsupported.push(api);
        }
      }
      return File;
    });

    File.support = function() {
      var list;
      list = function(names) {
        return (JSON.stringify(names)).replace(/\[(.*)\]/, '$1').replace(/"/g, "'").replace(/,/g, ", ").replace(/(.*),/, '$1 and');
      };
      if (File.unsupported.length === 0) {
        return "Your browser supports all the File-related APIs, i.e.:\n  " + (list(File.supported));
      } else if (File.supported.length === 0) {
        return "Your browser doesn't support any File-related APIs, i.e.:\n  " + (list(File.unsupported));
      } else {
        return "Your browser supports the following APIs:\n  " + (list(File.supported)) + "\nbut doesn't support:\n  " + (list(File.unsupported));
      }
    };

    File.fileType = function(fileName) {
      var extension, type;
      extension = fileName.match(/\.([0-9a-z]+)(?:[\?#]|$)/i);
      if (!((extension != null) && extension !== '' && extension.length > 0)) {
        return File.defaultType;
      }
      type = File.extensions.all[extension[1]];
      if (type != null) {
        return type;
      } else {
        return File.defaultType;
      }
    };

    File.isTextType = function(type) {
      var suffix, _i, _len, _ref;
      if (File.types.text[type] != null) {
        return true;
      }
      if (/^text\//.test(type)) {
        return true;
      }
      _ref = ['json', 'xml'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        suffix = _ref[_i];
        if (new RegExp("" + suffix + "$").test(type)) {
          return true;
        }
      }
      return false;
    };

    File.isWebImageType = function(type) {
      return File.types.webImage[type] != null;
    };

    File.isMyImageFile = function(type) {
      return File.types.MyImage[type] != null;
    };

    File.readFile = function(file, onRead) {
      var reader;
      reader = new FileReader();
      if (File.isTextType(file.type)) {
        reader.readAsText(file);
      } else {
        reader.readAsDataURL(file);
      }
      return reader.onloadend = (function(_this) {
        return function(event) {
          return onRead(file, event.target.result);
        };
      })(this);
    };

    File.read = function(onRead, onError, onFilesMetaData) {
      if (typeof FileReader !== "undefined" && FileReader !== null) {
        if (!File.dom.input) {
          File.dom.input = $('<input>').attr({
            type: 'file',
            href: '#'
          }).hide().appendTo(File.dom.body);
        }
        File.dom.input.on('change', function() {
          var file, files, _i, _len, _results;
          files = $(this).get(0).files;
          if (onFilesMetaData != null) {
            onFilesMetaData(files);
          }
          _results = [];
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            file = files[_i];
            _results.push(File.readFile(file, onRead));
          }
          return _results;
        });
        return File.dom.input.trigger('click');
      } else {
        if (onError != null) {
          return onError("Your browser doesn't support reading files, sorry...");
        }
      }
    };

    File.write = function(fileName, data, onError, onWritten) {
      var cleanUp, href, options, type;
      if ((typeof URL !== "undefined" && URL !== null) && (typeof Blob !== "undefined" && Blob !== null)) {
        if (!File.dom.a) {
          File.dom.a = $('<a>').hide().appendTo(File.dom.body);
        }
        type = File.fileType(fileName);
        href = URL.createObjectURL(new Blob([data], {
          type: type
        }));
        options = {
          download: fileName,
          href: href,
          'data-downloadurl': "" + type + ":" + fileName + ":" + href
        };
        File.dom.a.attr(options);
        File.dom.a[0].click();
        cleanUp = function() {
          return URL.revokeObjectURL(href);
        };
        return setTimeout(cleanUp, 1500);
      } else {
        if (onError != null) {
          return onError("Your browser doesn't support writing files, sorry...");
        }
      }
    };

    return File;

  })();

}).call(this);
